// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Supply.sol";

contract Ticketing is ERC1155, Ownable, ERC1155Supply {

    address public vendor;
    address public goodCause;
    uint [] public ticketPrice;
    string public title;
    uint public immutable maxTicketsPerCustomer;
    uint[] public numTickets;
    uint[] public numOfClass;
    uint[] public ticketClass;
    uint public endTime;

    
    constructor(address _vendor, address _goodCause, string memory _title, 
        uint[] memory _ticketPrice,  uint _durationDays, uint _maxTicketsPerCustomer, 
        uint[] memory _numTickets, uint[] memory _ticketClass, uint[] memory _numOfClass)
                ERC1155("https://bafybeigcdcsgioecw47pvbz2ehibuj75rxofwhhec3mfh5g2jz5nbt43ci.ipfs.dweb.link/{id].json") {
        
        vendor = _vendor;
        goodCause = _goodCause;
        title = _title;
        numOfClass = _numOfClass;
        ticketClass = _ticketClass;
        numTickets = _numTickets;
        ticketPrice = _ticketPrice;
        maxTicketsPerCustomer = _maxTicketsPerCustomer;
        endTime = block.timestamp + _durationDays * 1 days;

    }

    // The following functions are overrides required by Solidity.

    function _beforeTokenTransfer(address operator, address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data)
        internal
        override(ERC1155, ERC1155Supply)
    {
        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);
    } 

    uint public requestedNumTickets;
    uint public totalNumOfTickets;
    uint public payments;
    address public buyer;
    uint public availableTickets;

    mapping(address => uint) public pendingPayments;   
    mapping(address => uint) public purchasedTickets; 

    function buyTickets (uint _requestedNumTickets, uint[] memory _ticketClass) 
        public payable {

            require (block.timestamp < endTime, "Sale already ended");
            require (requestedNumTickets <= maxTicketsPerCustomer);

            buyer = msg.sender;
            requestedNumTickets = _requestedNumTickets;
            ticketClass = _ticketClass;

            pendingPayments[buyer] += msg.value;
    }

    function setURI(string memory newuri) public onlyOwner {
        _setURI(newuri);
    }

    address public account;
    uint public amount;
    bytes public data;

    function mintTickets(address _account, uint256[] calldata _ticketClass, uint256 _amount, 
        bytes memory _data)
        public
    {
        account = msg.sender;
        ticketClass = _ticketClass;
        amount = _amount;
        data = _data;

        require(pendingPayments[msg.sender] >= amount * ticketPrice[ticketClass]);
        require(amount <= availableTickets[ticketClass]);
        require(amount + purchasedTickets[msg.sender] <= maxTicketsPerCustomer);

        pendingPayments[msg.sender] = pendingPayments[msg.sender] - (amount*ticketPrice[ticketClass]);
        purchasedTickets[msg.sender] = purchasedTickets[msg.sender] + amount;
        _mint(account, ticketClass, amount, data);
    }
}


    


