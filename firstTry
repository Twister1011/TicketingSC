// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Supply.sol";

contract Ticketing is ERC1155, Ownable, ERC1155Supply {

    address public vendor;
    address public goodCause;
    string public title;
    uint public immutable numOfClasses;
    uint public endTime;
    
    constructor(address _vendor, address _goodCause, string memory _title, 
        uint _durationDays, uint _numOfClasses)
                ERC1155("https://bafybeigcdcsgioecw47pvbz2ehibuj75rxofwhhec3mfh5g2jz5nbt43ci.ipfs.dweb.link/{id].json") {
        
        vendor = _vendor;
        goodCause = _goodCause;
        title = _title;
        numOfClasses = _numOfClasses;
        endTime = block.timestamp + _durationDays * 1 days;
     }

        uint [] public ticketPrice;
        uint public maxTicketsPerCustomer;
        uint[] public numTicketsClass;
        uint[] public ticketClass;

    function createTickets (uint[] memory numTicketsClass, uint[] memory ticketClass,
        uint[] memory ticketPrice, uint _maxTicketsPerCustomer) public
    {
        numTicketsClass = new uint[](numOfClasses);
        ticketClass = new uint[](numOfClasses);
        ticketPrice = new uint[](numOfClasses);
        maxTicketsPerCustomer = _maxTicketsPerCustomer;
    }
    // The following functions are overrides required by Solidity.

    function _beforeTokenTransfer(address operator, address from, address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data)
        internal
        override(ERC1155, ERC1155Supply)
    {
        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);
    } 

    uint public requestedNumTickets;
    uint public payments;
    address public buyer;
    uint public availableTickets;
    uint public amountReservedTickets;
    uint public checkReservedTickets;
    uint public payAmount;

    mapping(address => uint) public pendingPayments;   
    mapping(address => uint) public reservedTickets;
    //event reservedTickets (address indexed buyer, uint amount);

    function reserveTickets (uint _requestedNumTickets, uint _ticketClass, uint _payAmount) 
        public payable {

            require (block.timestamp < endTime, "Sale already ended");
            require (requestedNumTickets + reservedTickets[msg.sender] <= maxTicketsPerCustomer, 
            "You cannot reserve more tickets");

            requestedNumTickets = _requestedNumTickets;
            payAmount = _payAmount;

            if (requestedNumTickets != 0) {
                reservedTickets[msg.sender] += requestedNumTickets;
            }
            
            if (payAmount != 0) {
                pendingPayments[msg.sender] += payAmount;
            } 

    }

    function setURI(string memory newuri) public onlyOwner {
        _setURI(newuri);
    }

    address public account;
    uint public amount;
    bytes public data;

    function mintTickets(address account, uint256[] calldata _ticketClass, uint256 _amount, 
        bytes memory _data)
        public
    {
        account = msg.sender;
        ticketClass = _ticketClass;
        amount = _amount;
        data = _data;

        //require(pendingPayments[msg.sender] >= amount * ticketPrice[ticketClass]);
        //require(amount <= availableTickets[ticketClass]);
        //require(amount + purchasedTickets[msg.sender] <= maxTicketsPerCustomer);

       // pendingPayments[msg.sender] = pendingPayments[msg.sender] - (amount*ticketPrice[ticketClass]);
        //purchasedTickets[msg.sender] = purchasedTickets[msg.sender] + amount;
        //_mint(account, ticketClass, amount, data);
    }
}


    


